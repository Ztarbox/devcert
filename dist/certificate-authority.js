"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const createDebug = require("debug");
const constants_1 = require("./constants");
const platforms_1 = require("./platforms");
const utils_1 = require("./utils");
const certificates_1 = require("./certificates");
const path_1 = require("path");
const debug = createDebug('devcert:certificate-authority');
/**
 * Install the once-per-machine trusted root CA. We'll use this CA to sign
 * per-app certs.
 */
async function installCertificateAuthority(options = {}, certOptions) {
    debug(`Uninstalling existing certificates, which will be void once any existing CA is gone`);
    uninstall();
    constants_1.ensureConfigDirs();
    const tmp = utils_1.tmpDir();
    debug(`Making a temp working directory for files to copied in`);
    const rootKeyPath = path_1.join(tmp.name, 'ca.key');
    debug(`Generating the OpenSSL configuration needed to setup the certificate authority`);
    seedConfigFiles();
    debug(`Generating a private key`);
    certificates_1.generateKey(rootKeyPath);
    debug(`Generating a CA certificate`);
    utils_1.openssl(`req -new -x509 -config "${constants_1.caSelfSignConfig}" -key "${rootKeyPath}" -out "${constants_1.rootCACertPath}" -days ${certOptions.caCertExpiry}`, 'generating CA CSR');
    debug('Saving certificate authority credentials');
    await saveCertificateAuthorityCredentials(rootKeyPath);
    debug(`Adding the root certificate authority to trust stores`);
    await platforms_1.default.addToTrustStores(constants_1.rootCACertPath, options);
}
exports.default = installCertificateAuthority;
/**
 * Initializes the files OpenSSL needs to sign certificates as a certificate
 * authority, as well as our CA setup version
 */
function seedConfigFiles() {
    // This is v2 of the devcert certificate authority setup
    fs_1.writeFileSync(constants_1.caVersionFile, '2');
    // OpenSSL CA files
    fs_1.writeFileSync(constants_1.opensslDatabaseFilePath, '');
    fs_1.writeFileSync(constants_1.opensslSerialFilePath, '01');
}
async function withCertificateAuthorityCredentials(cb) {
    debug(`Retrieving devcert's certificate authority credentials`);
    const tmp = utils_1.tmpDir();
    const caKeyPath = path_1.join(tmp.name, 'ca.key');
    const caKey = await platforms_1.default.readProtectedFile(constants_1.rootCAKeyPath);
    fs_1.writeFileSync(caKeyPath, caKey);
    await cb({ caKeyPath, caCertPath: constants_1.rootCACertPath });
    fs_1.unlinkSync(caKeyPath);
    tmp.removeCallback();
}
exports.withCertificateAuthorityCredentials = withCertificateAuthorityCredentials;
async function saveCertificateAuthorityCredentials(keypath) {
    debug(`Saving devcert's certificate authority credentials`);
    const key = fs_1.readFileSync(keypath, 'utf-8');
    await platforms_1.default.writeProtectedFile(constants_1.rootCAKeyPath, key);
}
function certErrors() {
    try {
        utils_1.openssl(`x509 -in "${constants_1.rootCACertPath}" -noout`, 'checking for certificate errors');
        return '';
    }
    catch (e) {
        return e.toString();
    }
}
// This function helps to migrate from v1.0.x to >= v1.1.0.
/**
 * Smoothly migrate the certificate storage from v1.0.x to >= v1.1.0.
 * In v1.1.0 there are new options for retrieving the CA cert directly,
 * to help third-party Node apps trust the root CA.
 *
 * If a v1.0.x cert already exists, then devcert has written it with
 * platform.writeProtectedFile(), so an unprivileged readFile cannot access it.
 * Pre-detect and remedy this; it should only happen once per installation.
 */
async function ensureCACertReadable(options, certOptions) {
    if (!certErrors()) {
        return;
    }
    /**
     * on windows, writeProtectedFile left the cert encrypted on *nix, the cert
     * has no read permissions either way, openssl will fail and that means we
     * have to fix it
     */
    try {
        const caFileContents = await platforms_1.default.readProtectedFile(constants_1.rootCACertPath);
        platforms_1.default.deleteProtectedFiles(constants_1.rootCACertPath);
        fs_1.writeFileSync(constants_1.rootCACertPath, caFileContents);
    }
    catch (e) {
        return installCertificateAuthority(options, certOptions);
    }
    // double check that we have a live one
    const remainingErrors = certErrors();
    if (remainingErrors) {
        return installCertificateAuthority(options, certOptions);
    }
}
exports.ensureCACertReadable = ensureCACertReadable;
/**
 * Remove as much of the devcert files and state as we can. This is necessary
 * when generating a new root certificate, and should be available to API
 * consumers as well.
 *
 * Not all of it will be removable. If certutil is not installed, we'll leave
 * Firefox alone. We try to remove files with maximum permissions, and if that
 * fails, we'll silently fail.
 *
 * It's also possible that the command to untrust will not work, and we'll
 * silently fail that as well; with no existing certificates anymore, the
 * security exposure there is minimal.
 *
 * @public
 */
function uninstall() {
    platforms_1.default.removeFromTrustStores(constants_1.rootCACertPath);
    platforms_1.default.deleteProtectedFiles(constants_1.domainsDir);
    platforms_1.default.deleteProtectedFiles(constants_1.rootCADir);
    platforms_1.default.deleteProtectedFiles(constants_1.getLegacyConfigDir());
}
exports.uninstall = uninstall;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2VydGlmaWNhdGUtYXV0aG9yaXR5LmpzIiwic291cmNlUm9vdCI6Ii4vIiwic291cmNlcyI6WyJjZXJ0aWZpY2F0ZS1hdXRob3JpdHkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwyQkFJWTtBQUNaLHFDQUFxQztBQUVyQywyQ0FXcUI7QUFDckIsMkNBQTBDO0FBQzFDLG1DQUEwQztBQUMxQyxpREFBNkM7QUFFN0MsK0JBQTRCO0FBRTVCLE1BQU0sS0FBSyxHQUFHLFdBQVcsQ0FBQywrQkFBK0IsQ0FBQyxDQUFDO0FBRTNEOzs7R0FHRztBQUNZLEtBQUssVUFBVSwyQkFBMkIsQ0FDdkQsVUFBbUIsRUFBRSxFQUNyQixXQUF3QjtJQUV4QixLQUFLLENBQ0gscUZBQXFGLENBQ3RGLENBQUM7SUFDRixTQUFTLEVBQUUsQ0FBQztJQUNaLDRCQUFnQixFQUFFLENBQUM7SUFFbkIsTUFBTSxHQUFHLEdBQUcsY0FBTSxFQUFFLENBQUM7SUFDckIsS0FBSyxDQUFDLHdEQUF3RCxDQUFDLENBQUM7SUFDaEUsTUFBTSxXQUFXLEdBQUcsV0FBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFFN0MsS0FBSyxDQUNILGdGQUFnRixDQUNqRixDQUFDO0lBQ0YsZUFBZSxFQUFFLENBQUM7SUFFbEIsS0FBSyxDQUFDLDBCQUEwQixDQUFDLENBQUM7SUFDbEMsMEJBQVcsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUV6QixLQUFLLENBQUMsNkJBQTZCLENBQUMsQ0FBQztJQUNyQyxlQUFPLENBQ0wsMkJBQTJCLDRCQUFnQixXQUFXLFdBQVcsV0FBVywwQkFBYyxXQUFXLFdBQVcsQ0FBQyxZQUFZLEVBQUUsRUFDL0gsbUJBQW1CLENBQ3BCLENBQUM7SUFFRixLQUFLLENBQUMsMENBQTBDLENBQUMsQ0FBQztJQUNsRCxNQUFNLG1DQUFtQyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBRXZELEtBQUssQ0FBQyx1REFBdUQsQ0FBQyxDQUFDO0lBQy9E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QkFBa0IsRUFBRSxDQUFDLENBQUM7QUFDN0QsQ0FBQztBQUxELDhCQUtDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICByZWFkRmlsZVN5bmMgYXMgcmVhZEZpbGUsXHJcbiAgd3JpdGVGaWxlU3luYyBhcyB3cml0ZUZpbGUsXHJcbiAgdW5saW5rU3luY1xyXG59IGZyb20gJ2ZzJztcclxuaW1wb3J0ICogYXMgY3JlYXRlRGVidWcgZnJvbSAnZGVidWcnO1xyXG5cclxuaW1wb3J0IHtcclxuICBkb21haW5zRGlyLFxyXG4gIHJvb3RDQURpcixcclxuICBlbnN1cmVDb25maWdEaXJzLFxyXG4gIGdldExlZ2FjeUNvbmZpZ0RpcixcclxuICByb290Q0FLZXlQYXRoLFxyXG4gIHJvb3RDQUNlcnRQYXRoLFxyXG4gIGNhU2VsZlNpZ25Db25maWcsXHJcbiAgb3BlbnNzbFNlcmlhbEZpbGVQYXRoLFxyXG4gIG9wZW5zc2xEYXRhYmFzZUZpbGVQYXRoLFxyXG4gIGNhVmVyc2lvbkZpbGVcclxufSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCBjdXJyZW50UGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybXMnO1xyXG5pbXBvcnQgeyBvcGVuc3NsLCB0bXBEaXIgfSBmcm9tICcuL3V0aWxzJztcclxuaW1wb3J0IHsgZ2VuZXJhdGVLZXkgfSBmcm9tICcuL2NlcnRpZmljYXRlcyc7XHJcbmltcG9ydCB7IE9wdGlvbnMsIENlcnRPcHRpb25zIH0gZnJvbSAnLi9pbmRleCc7XHJcbmltcG9ydCB7IGpvaW4gfSBmcm9tICdwYXRoJztcclxuXHJcbmNvbnN0IGRlYnVnID0gY3JlYXRlRGVidWcoJ2RldmNlcnQ6Y2VydGlmaWNhdGUtYXV0aG9yaXR5Jyk7XHJcblxyXG4vKipcclxuICogSW5zdGFsbCB0aGUgb25jZS1wZXItbWFjaGluZSB0cnVzdGVkIHJvb3QgQ0EuIFdlJ2xsIHVzZSB0aGlzIENBIHRvIHNpZ25cclxuICogcGVyLWFwcCBjZXJ0cy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGluc3RhbGxDZXJ0aWZpY2F0ZUF1dGhvcml0eShcclxuICBvcHRpb25zOiBPcHRpb25zID0ge30sXHJcbiAgY2VydE9wdGlvbnM6IENlcnRPcHRpb25zXHJcbik6IFByb21pc2U8dm9pZD4ge1xyXG4gIGRlYnVnKFxyXG4gICAgYFVuaW5zdGFsbGluZyBleGlzdGluZyBjZXJ0aWZpY2F0ZXMsIHdoaWNoIHdpbGwgYmUgdm9pZCBvbmNlIGFueSBleGlzdGluZyBDQSBpcyBnb25lYFxyXG4gICk7XHJcbiAgdW5pbnN0YWxsKCk7XHJcbiAgZW5zdXJlQ29uZmlnRGlycygpO1xyXG5cclxuICBjb25zdCB0bXAgPSB0bXBEaXIoKTtcclxuICBkZWJ1ZyhgTWFraW5nIGEgdGVtcCB3b3JraW5nIGRpcmVjdG9yeSBmb3IgZmlsZXMgdG8gY29waWVkIGluYCk7XHJcbiAgY29uc3Qgcm9vdEtleVBhdGggPSBqb2luKHRtcC5uYW1lLCAnY2Eua2V5Jyk7XHJcblxyXG4gIGRlYnVnKFxyXG4gICAgYEdlbmVyYXRpbmcgdGhlIE9wZW5TU0wgY29uZmlndXJhdGlvbiBuZWVkZWQgdG8gc2V0dXAgdGhlIGNlcnRpZmljYXRlIGF1dGhvcml0eWBcclxuICApO1xyXG4gIHNlZWRDb25maWdGaWxlcygpO1xyXG5cclxuICBkZWJ1ZyhgR2VuZXJhdGluZyBhIHByaXZhdGUga2V5YCk7XHJcbiAgZ2VuZXJhdGVLZXkocm9vdEtleVBhdGgpO1xyXG5cclxuICBkZWJ1ZyhgR2VuZXJhdGluZyBhIENBIGNlcnRpZmljYXRlYCk7XHJcbiAgb3BlbnNzbChcclxuICAgIGByZXEgLW5ldyAteDUwOSAtY29uZmlnIFwiJHtjYVNlbGZTaWduQ29uZmlnfVwiIC1rZXkgXCIke3Jvb3RLZXlQYXRofVwiIC1vdXQgXCIke3Jvb3RDQUNlcnRQYXRofVwiIC1kYXlzICR7Y2VydE9wdGlvbnMuY2FDZXJ0RXhwaXJ5fWAsXHJcbiAgICAnZ2VuZXJhdGluZyBDQSBDU1InXHJcbiAgKTtcclxuXHJcbiAgZGVidWcoJ1NhdmluZyBjZXJ0aWZpY2F0ZSBhdXRob3JpdHkgY3JlZGVudGlhbHMnKTtcclxuICBhd2FpdCBzYXZlQ2VydGlmaWNhdGVBdXRob3JpdHlDcmVkZW50aWFscyhyb290S2V5UGF0aCk7XHJcblxyXG4gIGRlYnVnKGBBZGRpbmcgdGhlIHJvb3QgY2VydGlmaWNhdGUgYXV0aG9yaXR5IHRvIHRydXN0IHN0b3Jlc2ApO1xyXG4gIGF3YWl0IGN1cnJlbnRQbGF0Zm9ybS5hZGRUb1RydXN0U3RvcmVzKHJvb3RDQUNlcnRQYXRoLCBvcHRpb25zKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemVzIHRoZSBmaWxlcyBPcGVuU1NMIG5lZWRzIHRvIHNpZ24gY2VydGlmaWNhdGVzIGFzIGEgY2VydGlmaWNhdGVcclxuICogYXV0aG9yaXR5LCBhcyB3ZWxsIGFzIG91ciBDQSBzZXR1cCB2ZXJzaW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBzZWVkQ29uZmlnRmlsZXMoKTogdm9pZCB7XHJcbiAgLy8gVGhpcyBpcyB2MiBvZiB0aGUgZGV2Y2VydCBjZXJ0aWZpY2F0ZSBhdXRob3JpdHkgc2V0dXBcclxuICB3cml0ZUZpbGUoY2FWZXJzaW9uRmlsZSwgJzInKTtcclxuICAvLyBPcGVuU1NMIENBIGZpbGVzXHJcbiAgd3JpdGVGaWxlKG9wZW5zc2xEYXRhYmFzZUZpbGVQYXRoLCAnJyk7XHJcbiAgd3JpdGVGaWxlKG9wZW5zc2xTZXJpYWxGaWxlUGF0aCwgJzAxJyk7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3aXRoQ2VydGlmaWNhdGVBdXRob3JpdHlDcmVkZW50aWFscyhcclxuICBjYjogKHtcclxuICAgIGNhS2V5UGF0aCxcclxuICAgIGNhQ2VydFBhdGhcclxuICB9OiB7XHJcbiAgICBjYUtleVBhdGg6IHN0cmluZztcclxuICAgIGNhQ2VydFBhdGg6IHN0cmluZztcclxuICB9KSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZFxyXG4pOiBQcm9taXNlPHZvaWQ+IHtcclxuICBkZWJ1ZyhgUmV0cmlldmluZyBkZXZjZXJ0J3MgY2VydGlmaWNhdGUgYXV0aG9yaXR5IGNyZWRlbnRpYWxzYCk7XHJcbiAgY29uc3QgdG1wID0gdG1wRGlyKCk7XHJcbiAgY29uc3QgY2FLZXlQYXRoID0gam9pbih0bXAubmFtZSwgJ2NhLmtleScpO1xyXG4gIGNvbnN0IGNhS2V5ID0gYXdhaXQgY3VycmVudFBsYXRmb3JtLnJlYWRQcm90ZWN0ZWRGaWxlKHJvb3RDQUtleVBhdGgpO1xyXG4gIHdyaXRlRmlsZShjYUtleVBhdGgsIGNhS2V5KTtcclxuICBhd2FpdCBjYih7IGNhS2V5UGF0aCwgY2FDZXJ0UGF0aDogcm9vdENBQ2VydFBhdGggfSk7XHJcbiAgdW5saW5rU3luYyhjYUtleVBhdGgpO1xyXG4gIHRtcC5yZW1vdmVDYWxsYmFjaygpO1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBzYXZlQ2VydGlmaWNhdGVBdXRob3JpdHlDcmVkZW50aWFscyhcclxuICBrZXlwYXRoOiBzdHJpbmdcclxuKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgZGVidWcoYFNhdmluZyBkZXZjZXJ0J3MgY2VydGlmaWNhdGUgYXV0aG9yaXR5IGNyZWRlbnRpYWxzYCk7XHJcbiAgY29uc3Qga2V5ID0gcmVhZEZpbGUoa2V5cGF0aCwgJ3V0Zi04Jyk7XHJcbiAgYXdhaXQgY3VycmVudFBsYXRmb3JtLndyaXRlUHJvdGVjdGVkRmlsZShyb290Q0FLZXlQYXRoLCBrZXkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjZXJ0RXJyb3JzKCk6IHN0cmluZyB7XHJcbiAgdHJ5IHtcclxuICAgIG9wZW5zc2woXHJcbiAgICAgIGB4NTA5IC1pbiBcIiR7cm9vdENBQ2VydFBhdGh9XCIgLW5vb3V0YCxcclxuICAgICAgJ2NoZWNraW5nIGZvciBjZXJ0aWZpY2F0ZSBlcnJvcnMnXHJcbiAgICApO1xyXG4gICAgcmV0dXJuICcnO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIHJldHVybiBlLnRvU3RyaW5nKCk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBUaGlzIGZ1bmN0aW9uIGhlbHBzIHRvIG1pZ3JhdGUgZnJvbSB2MS4wLnggdG8gPj0gdjEuMS4wLlxyXG4vKipcclxuICogU21vb3RobHkgbWlncmF0ZSB0aGUgY2VydGlmaWNhdGUgc3RvcmFnZSBmcm9tIHYxLjAueCB0byA+PSB2MS4xLjAuXHJcbiAqIEluIHYxLjEuMCB0aGVyZSBhcmUgbmV3IG9wdGlvbnMgZm9yIHJldHJpZXZpbmcgdGhlIENBIGNlcnQgZGlyZWN0bHksXHJcbiAqIHRvIGhlbHAgdGhpcmQtcGFydHkgTm9kZSBhcHBzIHRydXN0IHRoZSByb290IENBLlxyXG4gKlxyXG4gKiBJZiBhIHYxLjAueCBjZXJ0IGFscmVhZHkgZXhpc3RzLCB0aGVuIGRldmNlcnQgaGFzIHdyaXR0ZW4gaXQgd2l0aFxyXG4gKiBwbGF0Zm9ybS53cml0ZVByb3RlY3RlZEZpbGUoKSwgc28gYW4gdW5wcml2aWxlZ2VkIHJlYWRGaWxlIGNhbm5vdCBhY2Nlc3MgaXQuXHJcbiAqIFByZS1kZXRlY3QgYW5kIHJlbWVkeSB0aGlzOyBpdCBzaG91bGQgb25seSBoYXBwZW4gb25jZSBwZXIgaW5zdGFsbGF0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVuc3VyZUNBQ2VydFJlYWRhYmxlKFxyXG4gIG9wdGlvbnM6IE9wdGlvbnMsXHJcbiAgY2VydE9wdGlvbnM6IENlcnRPcHRpb25zXHJcbik6IFByb21pc2U8dm9pZD4ge1xyXG4gIGlmICghY2VydEVycm9ycygpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIG9uIHdpbmRvd3MsIHdyaXRlUHJvdGVjdGVkRmlsZSBsZWZ0IHRoZSBjZXJ0IGVuY3J5cHRlZCBvbiAqbml4LCB0aGUgY2VydFxyXG4gICAqIGhhcyBubyByZWFkIHBlcm1pc3Npb25zIGVpdGhlciB3YXksIG9wZW5zc2wgd2lsbCBmYWlsIGFuZCB0aGF0IG1lYW5zIHdlXHJcbiAgICogaGF2ZSB0byBmaXggaXRcclxuICAgKi9cclxuICB0cnkge1xyXG4gICAgY29uc3QgY2FGaWxlQ29udGVudHMgPSBhd2FpdCBjdXJyZW50UGxhdGZvcm0ucmVhZFByb3RlY3RlZEZpbGUoXHJcbiAgICAgIHJvb3RDQUNlcnRQYXRoXHJcbiAgICApO1xyXG4gICAgY3VycmVudFBsYXRmb3JtLmRlbGV0ZVByb3RlY3RlZEZpbGVzKHJvb3RDQUNlcnRQYXRoKTtcclxuICAgIHdyaXRlRmlsZShyb290Q0FDZXJ0UGF0aCwgY2FGaWxlQ29udGVudHMpO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIHJldHVybiBpbnN0YWxsQ2VydGlmaWNhdGVBdXRob3JpdHkob3B0aW9ucywgY2VydE9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgLy8gZG91YmxlIGNoZWNrIHRoYXQgd2UgaGF2ZSBhIGxpdmUgb25lXHJcbiAgY29uc3QgcmVtYWluaW5nRXJyb3JzID0gY2VydEVycm9ycygpO1xyXG4gIGlmIChyZW1haW5pbmdFcnJvcnMpIHtcclxuICAgIHJldHVybiBpbnN0YWxsQ2VydGlmaWNhdGVBdXRob3JpdHkob3B0aW9ucywgY2VydE9wdGlvbnMpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSBhcyBtdWNoIG9mIHRoZSBkZXZjZXJ0IGZpbGVzIGFuZCBzdGF0ZSBhcyB3ZSBjYW4uIFRoaXMgaXMgbmVjZXNzYXJ5XHJcbiAqIHdoZW4gZ2VuZXJhdGluZyBhIG5ldyByb290IGNlcnRpZmljYXRlLCBhbmQgc2hvdWxkIGJlIGF2YWlsYWJsZSB0byBBUElcclxuICogY29uc3VtZXJzIGFzIHdlbGwuXHJcbiAqXHJcbiAqIE5vdCBhbGwgb2YgaXQgd2lsbCBiZSByZW1vdmFibGUuIElmIGNlcnR1dGlsIGlzIG5vdCBpbnN0YWxsZWQsIHdlJ2xsIGxlYXZlXHJcbiAqIEZpcmVmb3ggYWxvbmUuIFdlIHRyeSB0byByZW1vdmUgZmlsZXMgd2l0aCBtYXhpbXVtIHBlcm1pc3Npb25zLCBhbmQgaWYgdGhhdFxyXG4gKiBmYWlscywgd2UnbGwgc2lsZW50bHkgZmFpbC5cclxuICpcclxuICogSXQncyBhbHNvIHBvc3NpYmxlIHRoYXQgdGhlIGNvbW1hbmQgdG8gdW50cnVzdCB3aWxsIG5vdCB3b3JrLCBhbmQgd2UnbGxcclxuICogc2lsZW50bHkgZmFpbCB0aGF0IGFzIHdlbGw7IHdpdGggbm8gZXhpc3RpbmcgY2VydGlmaWNhdGVzIGFueW1vcmUsIHRoZVxyXG4gKiBzZWN1cml0eSBleHBvc3VyZSB0aGVyZSBpcyBtaW5pbWFsLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdW5pbnN0YWxsKCk6IHZvaWQge1xyXG4gIGN1cnJlbnRQbGF0Zm9ybS5yZW1vdmVGcm9tVHJ1c3RTdG9yZXMocm9vdENBQ2VydFBhdGgpO1xyXG4gIGN1cnJlbnRQbGF0Zm9ybS5kZWxldGVQcm90ZWN0ZWRGaWxlcyhkb21haW5zRGlyKTtcclxuICBjdXJyZW50UGxhdGZvcm0uZGVsZXRlUHJvdGVjdGVkRmlsZXMocm9vdENBRGlyKTtcclxuICBjdXJyZW50UGxhdGZvcm0uZGVsZXRlUHJvdGVjdGVkRmlsZXMoZ2V0TGVnYWN5Q29uZmlnRGlyKCkpO1xyXG59XHJcbiJdfQ==