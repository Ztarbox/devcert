"use strict";
/**
 * @packageDocumentation
 * Utilities for safely generating locally-trusted and machine-specific X.509 certificates for local development
 */
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const createDebug = require("debug");
const command_exists_1 = require("command-exists");
const rimraf = require("rimraf");
const constants_1 = require("./constants");
const platforms_1 = require("./platforms");
const certificate_authority_1 = require("./certificate-authority");
exports.uninstall = certificate_authority_1.uninstall;
const certificates_1 = require("./certificates");
const user_interface_1 = require("./user-interface");
const node_forge_1 = require("node-forge");
const date_fns_1 = require("date-fns");
const utils_1 = require("./utils");
const debug = createDebug('devcert');
const REMAINING_BUSINESS_DAYS_VALIDITY_BEFORE_RENEW = 5;
const DEFAULT_CERT_OPTIONS = {
    caCertExpiry: 180,
    domainCertExpiry: 30
};
async function certificateFor(commonName, optionsOrAlternativeNames, options, partialCertOptions) {
    if (Array.isArray(optionsOrAlternativeNames)) {
        return certificateForImpl(commonName, optionsOrAlternativeNames, options, partialCertOptions);
    }
    else {
        return certificateForImpl(commonName, [], options, partialCertOptions);
    }
}
exports.certificateFor = certificateFor;
function getExpireAndRenewalDates(crt, renewalBufferInBusinessDays) {
    const expireAt = _getExpireDate(crt);
    const renewBy = date_fns_1.subBusinessDays(expireAt, renewalBufferInBusinessDays);
    return { expireAt, renewBy };
}
function getCertPortionOfPemString(crt) {
    const beginStr = '-----BEGIN CERTIFICATE-----';
    const endStr = '-----END CERTIFICATE-----';
    const begin = crt.indexOf(beginStr);
    const end = crt.indexOf(endStr);
    if (begin < 0 || end < 0)
        throw new Error(`Improperly formatted PEM file. Expected to find ${beginStr} and ${endStr}
"${crt}"`);
    const certContent = crt.substr(begin, end - begin + endStr.length);
    return certContent;
}
function _getExpireDate(crt) {
    const certInfo = node_forge_1.pki.certificateFromPem(crt);
    const { notAfter } = certInfo.validity;
    return notAfter;
}
function shouldRenew(crt, renewalBufferInBusinessDays) {
    const now = new Date();
    const { expireAt, renewBy } = getExpireAndRenewalDates(crt, renewalBufferInBusinessDays);
    debug(`evaluating cert renewal\n- now:\t${now.toDateString()}\n- renew at:\t${renewBy.toDateString()}\n- expire at:\t${expireAt.toDateString()}`);
    return now.valueOf() >= renewBy.valueOf();
}
/**
 * Get the expiration and recommended renewal dates, for the latest issued
 * cert for a given common_name
 *
 * @alpha
 * @param commonName - common_name of cert whose expiration info is desired
 * @param renewalBufferInBusinessDays - number of business days before cert expiration, to start indicating that it should be renewed
 */
function getCertExpirationInfo(commonName, renewalBufferInBusinessDays = REMAINING_BUSINESS_DAYS_VALIDITY_BEFORE_RENEW) {
    const domainCertPath = utils_1.pathForDomain(commonName, `certificate.crt`);
    if (!fs_1.existsSync(domainCertPath))
        throw new Error(`cert for ${commonName} was not found`);
    const domainCert = fs_1.readFileSync(domainCertPath).toString();
    if (!domainCert) {
        throw new Error(`No certificate for ${commonName} exists`);
    }
    const crt = getCertPortionOfPemString(domainCert);
    const { expireAt, renewBy } = getExpireAndRenewalDates(crt, renewalBufferInBusinessDays);
    const mustRenew = shouldRenew(crt, renewalBufferInBusinessDays);
    return { mustRenew, expireAt, renewBy };
}
exports.getCertExpirationInfo = getCertExpirationInfo;
async function certificateForImpl(commonName, alternativeNames, options = {}, partialCertOptions = {}) {
    var _a;
    debug(`Certificate requested for ${commonName}. Skipping certutil install: ${Boolean(options.skipCertutilInstall)}. Skipping hosts file: ${Boolean(options.skipHostsFile)}`);
    const certOptions = Object.assign(Object.assign({}, DEFAULT_CERT_OPTIONS), partialCertOptions);
    if (options.ui) {
        Object.assign(user_interface_1.default, options.ui);
    }
    if (!constants_1.isMac && !constants_1.isLinux && !constants_1.isWindows) {
        throw new Error(`Platform not supported: "${process.platform}"`);
    }
    if (!command_exists_1.sync('openssl')) {
        throw new Error('OpenSSL not found: OpenSSL is required to generate SSL certificates - make sure it is installed and available in your PATH');
    }
    const domainKeyPath = utils_1.keyPathForDomain(commonName);
    const domainCertPath = utils_1.certPathForDomain(commonName);
    if (!fs_1.existsSync(constants_1.rootCAKeyPath)) {
        debug('Root CA is not installed yet, so it must be our first run. Installing root CA ...');
        await certificate_authority_1.default(options, certOptions);
    }
    else if (options.getCaBuffer || options.getCaPath) {
        debug('Root CA is not readable, but it probably is because an earlier version of devcert locked it. Trying to fix...');
        await certificate_authority_1.ensureCACertReadable(options, certOptions);
    }
    if (!fs_1.existsSync(domainCertPath)) {
        debug(`Can't find certificate file for ${commonName}, so it must be the first request for ${commonName}. Generating and caching ...`);
        await certificates_1.generateDomainCertificate(commonName, alternativeNames, certOptions);
    }
    else {
        const certContents = getCertPortionOfPemString(fs_1.readFileSync(domainCertPath).toString());
        const expireDate = _getExpireDate(certContents);
        if (shouldRenew(certContents, (_a = options.renewalBufferInBusinessDays) !== null && _a !== void 0 ? _a : REMAINING_BUSINESS_DAYS_VALIDITY_BEFORE_RENEW)) {
            debug(`Certificate for ${commonName} was close to expiring (on ${expireDate.toDateString()}). A fresh certificate will be generated for you`);
            await removeAndRevokeDomainCert(commonName);
            await certificates_1.generateDomainCertificate(commonName, alternativeNames, certOptions);
        }
        else {
            debug(`Certificate for ${commonName} was not close to expiring (on ${expireDate.toDateString()}).`);
        }
    }
    if (!options.skipHostsFile) {
        await platforms_1.default.addDomainToHostFileIfMissing(commonName);
    }
    debug(`Returning domain certificate`);
    const ret = {
        key: fs_1.readFileSync(domainKeyPath),
        cert: fs_1.readFileSync(domainCertPath)
    };
    if (options.getCaBuffer)
        ret.ca = fs_1.readFileSync(constants_1.rootCACertPath);
    if (options.getCaPath)
        ret.caPath = constants_1.rootCACertPath;
    return ret;
}
/**
 * Check whether a certificate with a given common_name has been installed
 *
 * @public
 * @param commonName - commonName of certificate whose existence is being checked
 */
function hasCertificateFor(commonName) {
    return fs_1.existsSync(utils_1.pathForDomain(commonName, `certificate.crt`));
}
exports.hasCertificateFor = hasCertificateFor;
/**
 * Get a list of domains that certifiates have been generated for
 * @alpha
 */
function configuredDomains() {
    return fs_1.readdirSync(constants_1.domainsDir);
}
exports.configuredDomains = configuredDomains;
/**
 * Remove a certificate
 * @public
 * @param commonName - commonName of cert to remove
 * @deprecated please use {@link removeAndRevokeDomainCert | removeAndRevokeDomainCert} to ensure that the OpenSSL cert removal is handled properly
 */
function removeDomain(commonName) {
    rimraf.sync(utils_1.pathForDomain(commonName));
}
exports.removeDomain = removeDomain;
/**
 * Remove a certificate and revoke it from the OpenSSL cert database
 * @public
 * @param commonName - commonName of cert to remove
 */
async function removeAndRevokeDomainCert(commonName) {
    debug(`removing domain certificate for ${commonName}`);
    const certFolderPath = utils_1.pathForDomain(commonName);
    const domainCertPath = utils_1.certPathForDomain(commonName);
    if (fs_1.existsSync(certFolderPath)) {
        debug(`cert found on disk for ${commonName}`);
        // revoke the cert
        debug(`revoking cert ${commonName}`);
        await certificates_1.revokeDomainCertificate(commonName);
        // delete the cert file
        debug(`deleting cert on disk for ${commonName} - ${fs_1.statSync(domainCertPath).size}`);
        removeDomain(commonName);
        debug(`deleted cert on disk for ${commonName} - ${fs_1.existsSync(domainCertPath)}`);
    }
    else
        debug(`cert not found on disk ${commonName}`);
    debug(`completed removing domain certificate for ${commonName}`);
}
exports.removeAndRevokeDomainCert = removeAndRevokeDomainCert;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiLi8iLCJzb3VyY2VzIjpbImluZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7O0dBR0c7O0FBRUgsMkJBTVk7QUFDWixxQ0FBcUM7QUFDckMsbURBQXVEO0FBQ3ZELGlDQUFpQztBQUNqQywyQ0FPcUI7QUFDckIsMkNBQTBDO0FBQzFDLG1FQUdpQztBQVN4QixvQkFWUCxpQ0FBUyxDQVVPO0FBUmxCLGlEQUd3QjtBQUN4QixxREFBcUQ7QUFDckQsMkNBQWlDO0FBQ2pDLHVDQUEyQztBQUMzQyxtQ0FBNkU7QUFHN0UsTUFBTSxLQUFLLEdBQUcsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBRXJDLE1BQU0sNkNBQTZDLEdBQUcsQ0FBQyxDQUFDO0FBK0V4RCxNQUFNLG9CQUFvQixHQUFnQjtJQUN4QyxZQUFZLEVBQUUsR0FBRztJQUNqQixnQkFBZ0IsRUFBRSxFQUFFO0NBQ3JCLENBQUM7QUE0Q0ssS0FBSyxVQUFVLGNBQWMsQ0FJbEMsVUFBa0IsRUFDbEIseUJBQXVDLEVBQ3ZDLE9BQVcsRUFDWCxrQkFBdUI7SUFFdkIsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLHlCQUF5QixDQUFDLEVBQUU7UUFDNUMsT0FBTyxrQkFBa0IsQ0FDdkIsVUFBVSxFQUNWLHlCQUF5QixFQUN6QixPQUFPLEVBQ1Asa0JBQWtCLENBQ25CLENBQUM7S0FDSDtTQUFNO1FBQ0wsT0FBTyxrQkFBa0IsQ0FBQyxVQUFVLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO0tBQ3hFO0FBQ0gsQ0FBQztBQW5CRCx3Q0FtQkM7QUFFRCxTQUFTLHdCQUF3QixDQUMvQixHQUFXLEVBQ1gsMkJBQW1DO0lBRW5DLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNyQyxNQUFNLE9BQU8sR0FBRywwQkFBZSxDQUFDLFFBQVEsRUFBRSwyQkFBMkIsQ0FBQyxDQUFDO0lBQ3ZFLE9BQU8s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MEIsVUFBVSxFQUFFLENBQUMsQ0FBQztJQUNyRCxLQUFLLENBQUMsNkNBQTZDLFVBQVUsRUFBRSxDQUFDLENBQUM7QUFDbkUsQ0FBQztBQXZCRCw4REF1QkMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXHJcbiAqIFV0aWxpdGllcyBmb3Igc2FmZWx5IGdlbmVyYXRpbmcgbG9jYWxseS10cnVzdGVkIGFuZCBtYWNoaW5lLXNwZWNpZmljIFguNTA5IGNlcnRpZmljYXRlcyBmb3IgbG9jYWwgZGV2ZWxvcG1lbnRcclxuICovXHJcblxyXG5pbXBvcnQge1xyXG4gIHJlYWRGaWxlU3luYyBhcyByZWFkRmlsZSxcclxuICByZWFkZGlyU3luYyBhcyByZWFkZGlyLFxyXG4gIGV4aXN0c1N5bmMgYXMgZXhpc3RzLFxyXG4gIGV4aXN0c1N5bmMsXHJcbiAgc3RhdFN5bmNcclxufSBmcm9tICdmcyc7XHJcbmltcG9ydCAqIGFzIGNyZWF0ZURlYnVnIGZyb20gJ2RlYnVnJztcclxuaW1wb3J0IHsgc3luYyBhcyBjb21tYW5kRXhpc3RzIH0gZnJvbSAnY29tbWFuZC1leGlzdHMnO1xyXG5pbXBvcnQgKiBhcyByaW1yYWYgZnJvbSAncmltcmFmJztcclxuaW1wb3J0IHtcclxuICBpc01hYyxcclxuICBpc0xpbnV4LFxyXG4gIGlzV2luZG93cyxcclxuICBkb21haW5zRGlyLFxyXG4gIHJvb3RDQUtleVBhdGgsXHJcbiAgcm9vdENBQ2VydFBhdGhcclxufSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCBjdXJyZW50UGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybXMnO1xyXG5pbXBvcnQgaW5zdGFsbENlcnRpZmljYXRlQXV0aG9yaXR5LCB7XHJcbiAgZW5zdXJlQ0FDZXJ0UmVhZGFibGUsXHJcbiAgdW5pbnN0YWxsXHJcbn0gZnJvbSAnLi9jZXJ0aWZpY2F0ZS1hdXRob3JpdHknO1xyXG5pbXBvcnQge1xyXG4gIGdlbmVyYXRlRG9tYWluQ2VydGlmaWNhdGUsXHJcbiAgcmV2b2tlRG9tYWluQ2VydGlmaWNhdGVcclxufSBmcm9tICcuL2NlcnRpZmljYXRlcyc7XHJcbmltcG9ydCBVSSwgeyBVc2VySW50ZXJmYWNlIH0gZnJvbSAnLi91c2VyLWludGVyZmFjZSc7XHJcbmltcG9ydCB7IHBraSB9IGZyb20gJ25vZGUtZm9yZ2UnO1xyXG5pbXBvcnQgeyBzdWJCdXNpbmVzc0RheXMgfSBmcm9tICdkYXRlLWZucyc7XHJcbmltcG9ydCB7IHBhdGhGb3JEb21haW4sIGtleVBhdGhGb3JEb21haW4sIGNlcnRQYXRoRm9yRG9tYWluIH0gZnJvbSAnLi91dGlscyc7XHJcbmV4cG9ydCB7IHVuaW5zdGFsbCwgVXNlckludGVyZmFjZSB9O1xyXG5cclxuY29uc3QgZGVidWcgPSBjcmVhdGVEZWJ1ZygnZGV2Y2VydCcpO1xyXG5cclxuY29uc3QgUkVNQUlOSU5HX0JVU0lORVNTX0RBWVNfVkFMSURJVFlfQkVGT1JFX1JFTkVXID0gNTtcclxuXHJcbi8qKlxyXG4gKiBDZXJ0aWZpY2F0ZSBvcHRpb25zXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ2VydE9wdGlvbnMge1xyXG4gIC8qKiBOdW1iZXIgb2YgZGF5cyBiZWZvcmUgdGhlIENBIGV4cGlyZXMgKi9cclxuICBjYUNlcnRFeHBpcnk6IG51bWJlcjtcclxuICAvKiogTnVtYmVyIG9mIGRheXMgYmVmb3JlIHRoZSBkb21haW4gY2VydGlmaWNhdGUgZXhwaXJlcyAqL1xyXG4gIGRvbWFpbkNlcnRFeHBpcnk6IG51bWJlcjtcclxufVxyXG4vKipcclxuICogQ2VydCBnZW5lcmF0aW9uIG9wdGlvbnNcclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25zIC8qIGV4dGVuZHMgUGFydGlhbDxJQ2FCdWZmZXJPcHRzICYgSUNhUGF0aE9wdHM+ICAqLyB7XHJcbiAgLyoqIFJldHVybiB0aGUgQ0EgY2VydGlmaWNhdGUgZGF0YT8gKi9cclxuICBnZXRDYUJ1ZmZlcj86IGJvb2xlYW47XHJcbiAgLyoqIFJldHVybiB0aGUgcGF0aCB0byB0aGUgQ0EgY2VydGlmaWNhdGU/ICovXHJcbiAgZ2V0Q2FQYXRoPzogYm9vbGVhbjtcclxuICAvKiogSWYgYGNlcnR1dGlsYCBpcyBub3QgaW5zdGFsbGVkIGFscmVhZHkgKGZvciB1cGRhdGluZyBuc3MgZGF0YWJhc2VzOyBlLmcuIGZpcmVmb3gpLCBkbyBub3QgYXR0ZW1wdCB0byBpbnN0YWxsIGl0ICovXHJcbiAgc2tpcENlcnR1dGlsSW5zdGFsbD86IGJvb2xlYW47XHJcbiAgLyoqIERvIG5vdCB1cGRhdGUgeW91ciBzeXN0ZW1zIGhvc3QgZmlsZSB3aXRoIHRoZSBkb21haW4gbmFtZSBvZiB0aGUgY2VydGlmaWNhdGUgKi9cclxuICBza2lwSG9zdHNGaWxlPzogYm9vbGVhbjtcclxuICAvKiogVXNlciBpbnRlcmZhY2UgaG9va3MgKi9cclxuICB1aT86IFVzZXJJbnRlcmZhY2U7XHJcbiAgLyoqIE51bWJlciBvZiBidXNpbmVzcyBkYXlzIGJlZm9yZSBkb21haW4gY2VydCBleHBpcnkgYmVmb3JlIGF1dG9tYXRpYyByZXZva2UgYW5kIHJlbmV3ICovXHJcbiAgcmVuZXdhbEJ1ZmZlckluQnVzaW5lc3NEYXlzPzogbnVtYmVyO1xyXG59XHJcbi8qKlxyXG4gKiBUaGUgQ0EgcHVibGljIGtleSBhcyBhIGJ1ZmZlclxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIENhQnVmZmVyIHtcclxuICAvKiogQ0EgcHVibGljIGtleSAqL1xyXG4gIGNhOiBCdWZmZXI7XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBjZXJ0IGF1dGhvcml0eSdzIHBhdGggb24gZGlza1xyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIENhUGF0aCB7XHJcbiAgLyoqIENBIGNlcnQgcGF0aCBvbiBkaXNrICovXHJcbiAgY2FQYXRoOiBzdHJpbmc7XHJcbn1cclxuLyoqXHJcbiAqIERvbWFpbiBjZXJ0IHB1YmxpYyBhbmQgcHJpdmF0ZSBrZXlzIGFzIGJ1ZmZlcnNcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBEb21haW5EYXRhIHtcclxuICAvKiogcHJpdmF0ZSBrZXkgKi9cclxuICBrZXk6IEJ1ZmZlcjtcclxuICAvKiogcHVibGljIGtleSAoY2VydCkgKi9cclxuICBjZXJ0OiBCdWZmZXI7XHJcbn1cclxuLyoqXHJcbiAqIEEgcmV0dXJuIHZhbHVlIGNvbnRhaW5pbmcgdGhlIENBIHB1YmxpYyBrZXlcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IHR5cGUgSVJldHVybkNhPE8gZXh0ZW5kcyBPcHRpb25zPiA9IE9bJ2dldENhQnVmZmVyJ10gZXh0ZW5kcyB0cnVlXHJcbiAgPyBDYUJ1ZmZlclxyXG4gIDogZmFsc2U7XHJcbi8qKlxyXG4gKiBBIHJldHVybiB2YWx1ZSBjb250YWluaW5nIHRoZSBDQSBwYXRoIG9uIGRpc2tcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IHR5cGUgSVJldHVybkNhUGF0aDxPIGV4dGVuZHMgT3B0aW9ucz4gPSBPWydnZXRDYVBhdGgnXSBleHRlbmRzIHRydWVcclxuICA/IENhUGF0aFxyXG4gIDogZmFsc2U7XHJcbi8qKlxyXG4gKiBBIHJldHVybiB2YWx1ZSBjb250YWluaW5nIHRoZSBDQSBwdWJsaWMga2V5LCBDQSBwYXRoIG9uIGRpc2ssIGFuZCBkb21haW4gY2VydCBpbmZvXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCB0eXBlIElSZXR1cm5EYXRhPE8gZXh0ZW5kcyBPcHRpb25zID0ge30+ID0gRG9tYWluRGF0YSAmXHJcbiAgSVJldHVybkNhPE8+ICZcclxuICBJUmV0dXJuQ2FQYXRoPE8+O1xyXG5cclxuY29uc3QgREVGQVVMVF9DRVJUX09QVElPTlM6IENlcnRPcHRpb25zID0ge1xyXG4gIGNhQ2VydEV4cGlyeTogMTgwLFxyXG4gIGRvbWFpbkNlcnRFeHBpcnk6IDMwXHJcbn07XHJcblxyXG4vKipcclxuICogUmVxdWVzdCBhbiBTU0wgY2VydGlmaWNhdGUgZm9yIHRoZSBnaXZlbiBhcHAgbmFtZSBzaWduZWQgYnkgdGhlIGRldmNlcnQgcm9vdFxyXG4gKiBjZXJ0aWZpY2F0ZSBhdXRob3JpdHkuIElmIGRldmNlcnQgaGFzIHByZXZpb3VzbHkgZ2VuZXJhdGVkIGEgY2VydGlmaWNhdGUgZm9yXHJcbiAqIHRoYXQgYXBwIG5hbWUgb24gdGhpcyBtYWNoaW5lLCBpdCB3aWxsIHJldXNlIHRoYXQgY2VydGlmaWNhdGUuXHJcbiAqXHJcbiAqIElmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgZGV2Y2VydCBpcyBiZWluZyBydW4gb24gdGhpcyBtYWNoaW5lLCBpdCB3aWxsXHJcbiAqIGdlbmVyYXRlIGFuZCBhdHRlbXB0IHRvIGluc3RhbGwgYSByb290IGNlcnRpZmljYXRlIGF1dGhvcml0eS5cclxuICpcclxuICogSWYgYG9wdGlvbnMuZ2V0Q2FCdWZmZXJgIGlzIHRydWUsIHJldHVybiB2YWx1ZSB3aWxsIGluY2x1ZGUgdGhlIGNhIGNlcnRpZmljYXRlIGRhdGFcclxuICogYXMgXFx7IGNhOiBCdWZmZXIgXFx9XHJcbiAqXHJcbiAqIElmIGBvcHRpb25zLmdldENhUGF0aGAgaXMgdHJ1ZSwgcmV0dXJuIHZhbHVlIHdpbGwgaW5jbHVkZSB0aGUgY2EgY2VydGlmaWNhdGUgcGF0aFxyXG4gKiBhcyBcXHsgY2FQYXRoOiBzdHJpbmcgXFx9XHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIGNvbW1vbk5hbWUgLSBjb21tb24gbmFtZSBmb3IgY2VydGlmaWNhdGVcclxuICogQHBhcmFtIGFsdGVybmF0aXZlTmFtZXMgLSBhbHRlcm5hdGUgbmFtZXMgZm9yIHRoZSBjZXJ0aWZpY2F0ZVxyXG4gKiBAcGFyYW0gb3B0aW9ucyAtIGNlcnQgZ2VuZXJhdGlvbiBvcHRpb25zXHJcbiAqIEBwYXJhbSBwYXJ0aWFsQ2VydE9wdGlvbnMgLSBjZXJ0aWZpY2F0ZSBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2VydGlmaWNhdGVGb3I8XHJcbiAgTyBleHRlbmRzIE9wdGlvbnMsXHJcbiAgQ08gZXh0ZW5kcyBQYXJ0aWFsPENlcnRPcHRpb25zPlxyXG4+KFxyXG4gIGNvbW1vbk5hbWU6IHN0cmluZyxcclxuICBhbHRlcm5hdGl2ZU5hbWVzOiBzdHJpbmdbXSxcclxuICBvcHRpb25zPzogTyxcclxuICBwYXJ0aWFsQ2VydE9wdGlvbnM/OiBDT1xyXG4pOiBQcm9taXNlPElSZXR1cm5EYXRhPE8+PjtcclxuXHJcbi8qKlxyXG4gKiB7QGluaGVyaXRkb2MgKGNlcnRpZmljYXRlRm9yOjEpfVxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2VydGlmaWNhdGVGb3I8XHJcbiAgTyBleHRlbmRzIE9wdGlvbnMsXHJcbiAgQ08gZXh0ZW5kcyBQYXJ0aWFsPENlcnRPcHRpb25zPlxyXG4+KFxyXG4gIGNvbW1vbk5hbWU6IHN0cmluZyxcclxuICBvcHRpb25zPzogTyxcclxuICBwYXJ0aWFsQ2VydE9wdGlvbnM/OiBDT1xyXG4pOiBQcm9taXNlPElSZXR1cm5EYXRhPE8+PjtcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNlcnRpZmljYXRlRm9yPFxyXG4gIE8gZXh0ZW5kcyBPcHRpb25zLFxyXG4gIENPIGV4dGVuZHMgUGFydGlhbDxDZXJ0T3B0aW9ucz5cclxuPihcclxuICBjb21tb25OYW1lOiBzdHJpbmcsXHJcbiAgb3B0aW9uc09yQWx0ZXJuYXRpdmVOYW1lczogc3RyaW5nW10gfCBPLFxyXG4gIG9wdGlvbnM/OiBPLFxyXG4gIHBhcnRpYWxDZXJ0T3B0aW9ucz86IENPXHJcbik6IFByb21pc2U8SVJldHVybkRhdGE8Tz4+IHtcclxuICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zT3JBbHRlcm5hdGl2ZU5hbWVzKSkge1xyXG4gICAgcmV0dXJuIGNlcnRpZmljYXRlRm9ySW1wbChcclxuICAgICAgY29tbW9uTmFtZSxcclxuICAgICAgb3B0aW9uc09yQWx0ZXJuYXRpdmVOYW1lcyxcclxuICAgICAgb3B0aW9ucyxcclxuICAgICAgcGFydGlhbENlcnRPcHRpb25zXHJcbiAgICApO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gY2VydGlmaWNhdGVGb3JJbXBsKGNvbW1vbk5hbWUsIFtdLCBvcHRpb25zLCBwYXJ0aWFsQ2VydE9wdGlvbnMpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RXhwaXJlQW5kUmVuZXdhbERhdGVzKFxyXG4gIGNydDogc3RyaW5nLFxyXG4gIHJlbmV3YWxCdWZmZXJJbkJ1c2luZXNzRGF5czogbnVtYmVyXHJcbik6IHsgZXhwaXJlQXQ6IERhdGU7IHJlbmV3Qnk6IERhdGUgfSB7XHJcbiAgY29uc3QgZXhwaXJlQXQgPSBfZ2V0RXhwaXJlRGF0ZShjcnQpO1xyXG4gIGNvbnN0IHJlbmV3QnkgPSBzdWJCdXNpbmVzc0RheXMoZXhwaXJlQXQsIHJlbmV3YWxCdWZmZXJJbkJ1c2luZXNzRGF5cyk7XHJcbiAgcmV0dXJuIHsgZXhwaXJlQXQsIHJlbmV3QnkgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0Q2VydFBvcnRpb25PZlBlbVN0cmluZyhjcnQ6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgY29uc3QgYmVnaW5TdHIgPSAnLS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tJztcclxuICBjb25zdCBlbmRTdHIgPSAnLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLSc7XHJcbiAgY29uc3QgYmVnaW4gPSBjcnQuaW5kZXhPZihiZWdpblN0cik7XHJcbiAgY29uc3QgZW5kID0gY3J0LmluZGV4T2YoZW5kU3RyKTtcclxuICBpZiAoYmVnaW4gPCAwIHx8IGVuZCA8IDApXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgIGBJbXByb3Blcmx5IGZvcm1hdHRlZCBQRU0gZmlsZS4gRXhwZWN0ZWQgdG8gZmluZCAke2JlZ2luU3RyfSBhbmQgJHtlbmRTdHJ9XHJcblwiJHtjcnR9XCJgXHJcbiAgICApO1xyXG5cclxuICBjb25zdCBjZXJ0Q29udGVudCA9IGNydC5zdWJzdHIoYmVnaW4sIGVuZCAtIGJlZ2luICsgZW5kU3RyLmxlbmd0aCk7XHJcbiAgcmV0dXJuIGNlcnRDb250ZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBfZ2V0RXhwaXJlRGF0ZShjcnQ6IHN0cmluZyk6IERhdGUge1xyXG4gIGNvbnN0IGNlcnRJbmZvID0gcGtpLmNlcnRpZmljYXRlRnJvbVBlbShjcnQpO1xyXG4gIGNvbnN0IHsgbm90QWZ0ZXIgfSA9IGNlcnRJbmZvLnZhbGlkaXR5O1xyXG4gIHJldHVybiBub3RBZnRlcjtcclxufVxyXG5cclxuZnVuY3Rpb24gc2hvdWxkUmVuZXcoXHJcbiAgY3J0OiBzdHJpbmcsXHJcbiAgcmVuZXdhbEJ1ZmZlckluQnVzaW5lc3NEYXlzOiBudW1iZXJcclxuKTogYm9vbGVhbiB7XHJcbiAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcclxuICBjb25zdCB7IGV4cGlyZUF0LCByZW5ld0J5IH0gPSBnZXRFeHBpcmVBbmRSZW5ld2FsRGF0ZXMoXHJcbiAgICBjcnQsXHJcbiAgICByZW5ld2FsQnVmZmVySW5CdXNpbmVzc0RheXNcclxuICApO1xyXG4gIGRlYnVnKFxyXG4gICAgYGV2YWx1YXRpbmcgY2VydCByZW5ld2FsXFxuLSBub3c6XFx0JHtub3cudG9EYXRlU3RyaW5nKCl9XFxuLSByZW5ldyBhdDpcXHQke3JlbmV3QnkudG9EYXRlU3RyaW5nKCl9XFxuLSBleHBpcmUgYXQ6XFx0JHtleHBpcmVBdC50b0RhdGVTdHJpbmcoKX1gXHJcbiAgKTtcclxuICByZXR1cm4gbm93LnZhbHVlT2YoKSA+PSByZW5ld0J5LnZhbHVlT2YoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgZXhwaXJhdGlvbiBhbmQgcmVjb21tZW5kZWQgcmVuZXdhbCBkYXRlcywgZm9yIHRoZSBsYXRlc3QgaXNzdWVkXHJcbiAqIGNlcnQgZm9yIGEgZ2l2ZW4gY29tbW9uX25hbWVcclxuICpcclxuICogQGFscGhhXHJcbiAqIEBwYXJhbSBjb21tb25OYW1lIC0gY29tbW9uX25hbWUgb2YgY2VydCB3aG9zZSBleHBpcmF0aW9uIGluZm8gaXMgZGVzaXJlZFxyXG4gKiBAcGFyYW0gcmVuZXdhbEJ1ZmZlckluQnVzaW5lc3NEYXlzIC0gbnVtYmVyIG9mIGJ1c2luZXNzIGRheXMgYmVmb3JlIGNlcnQgZXhwaXJhdGlvbiwgdG8gc3RhcnQgaW5kaWNhdGluZyB0aGF0IGl0IHNob3VsZCBiZSByZW5ld2VkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2VydEV4cGlyYXRpb25JbmZvKFxyXG4gIGNvbW1vbk5hbWU6IHN0cmluZyxcclxuICByZW5ld2FsQnVmZmVySW5CdXNpbmVzc0RheXMgPSBSRU1BSU5JTkdfQlVTSU5FU1NfREFZU19WQUxJRElUWV9CRUZPUkVfUkVORVdcclxuKTogeyBtdXN0UmVuZXc6IGJvb2xlYW47IHJlbmV3Qnk6IERhdGU7IGV4cGlyZUF0OiBEYXRlIH0ge1xyXG4gIGNvbnN0IGRvbWFpbkNlcnRQYXRoID0gcGF0aEZvckRvbWFpbihjb21tb25OYW1lLCBgY2VydGlmaWNhdGUuY3J0YCk7XHJcbiAgaWYgKCFleGlzdHMoZG9tYWluQ2VydFBhdGgpKVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBjZXJ0IGZvciAke2NvbW1vbk5hbWV9IHdhcyBub3QgZm91bmRgKTtcclxuICBjb25zdCBkb21haW5DZXJ0ID0gcmVhZEZpbGUoZG9tYWluQ2VydFBhdGgpLnRvU3RyaW5nKCk7XHJcbiAgaWYgKCFkb21haW5DZXJ0KSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGNlcnRpZmljYXRlIGZvciAke2NvbW1vbk5hbWV9IGV4aXN0c2ApO1xyXG4gIH1cclxuICBjb25zdCBjcnQgPSBnZXRDZXJ0UG9ydGlvbk9mUGVtU3RyaW5nKGRvbWFpbkNlcnQpO1xyXG4gIGNvbnN0IHsgZXhwaXJlQXQsIHJlbmV3QnkgfSA9IGdldEV4cGlyZUFuZFJlbmV3YWxEYXRlcyhcclxuICAgIGNydCxcclxuICAgIHJlbmV3YWxCdWZmZXJJbkJ1c2luZXNzRGF5c1xyXG4gICk7XHJcbiAgY29uc3QgbXVzdFJlbmV3ID0gc2hvdWxkUmVuZXcoY3J0LCByZW5ld2FsQnVmZmVySW5CdXNpbmVzc0RheXMpO1xyXG4gIHJldHVybiB7IG11c3RSZW5ldywgZXhwaXJlQXQsIHJlbmV3QnkgfTtcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gY2VydGlmaWNhdGVGb3JJbXBsPFxyXG4gIE8gZXh0ZW5kcyBPcHRpb25zLFxyXG4gIENPIGV4dGVuZHMgUGFydGlhbDxDZXJ0T3B0aW9ucz5cclxuPihcclxuICBjb21tb25OYW1lOiBzdHJpbmcsXHJcbiAgYWx0ZXJuYXRpdmVOYW1lczogc3RyaW5nW10sXHJcbiAgb3B0aW9uczogTyA9IHt9IGFzIE8sXHJcbiAgcGFydGlhbENlcnRPcHRpb25zOiBDTyA9IHt9IGFzIENPXHJcbik6IFByb21pc2U8SVJldHVybkRhdGE8Tz4+IHtcclxuICBkZWJ1ZyhcclxuICAgIGBDZXJ0aWZpY2F0ZSByZXF1ZXN0ZWQgZm9yICR7Y29tbW9uTmFtZX0uIFNraXBwaW5nIGNlcnR1dGlsIGluc3RhbGw6ICR7Qm9vbGVhbihcclxuICAgICAgb3B0aW9ucy5za2lwQ2VydHV0aWxJbnN0YWxsXHJcbiAgICApfS4gU2tpcHBpbmcgaG9zdHMgZmlsZTogJHtCb29sZWFuKG9wdGlvbnMuc2tpcEhvc3RzRmlsZSl9YFxyXG4gICk7XHJcbiAgY29uc3QgY2VydE9wdGlvbnM6IENlcnRPcHRpb25zID0ge1xyXG4gICAgLi4uREVGQVVMVF9DRVJUX09QVElPTlMsXHJcbiAgICAuLi5wYXJ0aWFsQ2VydE9wdGlvbnNcclxuICB9O1xyXG4gIGlmIChvcHRpb25zLnVpKSB7XHJcbiAgICBPYmplY3QuYXNzaWduKFVJLCBvcHRpb25zLnVpKTtcclxuICB9XHJcblxyXG4gIGlmICghaXNNYWMgJiYgIWlzTGludXggJiYgIWlzV2luZG93cykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBQbGF0Zm9ybSBub3Qgc3VwcG9ydGVkOiBcIiR7cHJvY2Vzcy5wbGF0Zm9ybX1cImApO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFjb21tYW5kRXhpc3RzKCdvcGVuc3NsJykpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgJ09wZW5TU0wgbm90IGZvdW5kOiBPcGVuU1NMIGlzIHJlcXVpcmVkIHRvIGdlbmVyYXRlIFNTTCBjZXJ0aWZpY2F0ZXMgLSBtYWtlIHN1cmUgaXQgaXMgaW5zdGFsbGVkIGFuZCBhdmFpbGFibGUgaW4geW91ciBQQVRIJ1xyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGRvbWFpbktleVBhdGggPSBrZXlQYXRoRm9yRG9tYWluKGNvbW1vbk5hbWUpO1xyXG4gIGNvbnN0IGRvbWFpbkNlcnRQYXRoID0gY2VydFBhdGhGb3JEb21haW4oY29tbW9uTmFtZSk7XHJcblxyXG4gIGlmICghZXhpc3RzKHJvb3RDQUtleVBhdGgpKSB7XHJcbiAgICBkZWJ1ZyhcclxuICAgICAgJ1Jvb3QgQ0EgaXMgbm90IGluc3RhbGxlZCB5ZXQsIHNvIGl0IG11c3QgYmUgb3VyIGZpcnN0IHJ1bi4gSW5zdGFsbGluZyByb290IENBIC4uLidcclxuICAgICk7XHJcbiAgICBhd2FpdCBpbnN0YWxsQ2VydGlmaWNhdGVBdXRob3JpdHkob3B0aW9ucywgY2VydE9wdGlvbnMpO1xyXG4gIH0gZWxzZSBpZiAob3B0aW9ucy5nZXRDYUJ1ZmZlciB8fCBvcHRpb25zLmdldENhUGF0aCkge1xyXG4gICAgZGVidWcoXHJcbiAgICAgICdSb290IENBIGlzIG5vdCByZWFkYWJsZSwgYnV0IGl0IHByb2JhYmx5IGlzIGJlY2F1c2UgYW4gZWFybGllciB2ZXJzaW9uIG9mIGRldmNlcnQgbG9ja2VkIGl0LiBUcnlpbmcgdG8gZml4Li4uJ1xyXG4gICAgKTtcclxuICAgIGF3YWl0IGVuc3VyZUNBQ2VydFJlYWRhYmxlKG9wdGlvbnMsIGNlcnRPcHRpb25zKTtcclxuICB9XHJcblxyXG4gIGlmICghZXhpc3RzKGRvbWFpbkNlcnRQYXRoKSkge1xyXG4gICAgZGVidWcoXHJcbiAgICAgIGBDYW4ndCBmaW5kIGNlcnRpZmljYXRlIGZpbGUgZm9yICR7Y29tbW9uTmFtZX0sIHNvIGl0IG11c3QgYmUgdGhlIGZpcnN0IHJlcXVlc3QgZm9yICR7Y29tbW9uTmFtZX0uIEdlbmVyYXRpbmcgYW5kIGNhY2hpbmcgLi4uYFxyXG4gICAgKTtcclxuICAgIGF3YWl0IGdlbmVyYXRlRG9tYWluQ2VydGlmaWNhdGUoY29tbW9uTmFtZSwgYWx0ZXJuYXRpdmVOYW1lcywgY2VydE9wdGlvbnMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zdCBjZXJ0Q29udGVudHMgPSBnZXRDZXJ0UG9ydGlvbk9mUGVtU3RyaW5nKFxyXG4gICAgICByZWFkRmlsZShkb21haW5DZXJ0UGF0aCkudG9TdHJpbmcoKVxyXG4gICAgKTtcclxuICAgIGNvbnN0IGV4cGlyZURhdGUgPSBfZ2V0RXhwaXJlRGF0ZShjZXJ0Q29udGVudHMpO1xyXG4gICAgaWYgKFxyXG4gICAgICBzaG91bGRSZW5ldyhcclxuICAgICAgICBjZXJ0Q29udGVudHMsXHJcbiAgICAgICAgb3B0aW9ucy5yZW5ld2FsQnVmZmVySW5CdXNpbmVzc0RheXMgPz9cclxuICAgICAgICAgIFJFTUFJTklOR19CVVNJTkVTU19EQVlTX1ZBTElESVRZX0JFRk9SRV9SRU5FV1xyXG4gICAgICApXHJcbiAgICApIHtcclxuICAgICAgZGVidWcoXHJcbiAgICAgICAgYENlcnRpZmljYXRlIGZvciAke2NvbW1vbk5hbWV9IHdhcyBjbG9zZSB0byBleHBpcmluZyAob24gJHtleHBpcmVEYXRlLnRvRGF0ZVN0cmluZygpfSkuIEEgZnJlc2ggY2VydGlmaWNhdGUgd2lsbCBiZSBnZW5lcmF0ZWQgZm9yIHlvdWBcclxuICAgICAgKTtcclxuICAgICAgYXdhaXQgcmVtb3ZlQW5kUmV2b2tlRG9tYWluQ2VydChjb21tb25OYW1lKTtcclxuICAgICAgYXdhaXQgZ2VuZXJhdGVEb21haW5DZXJ0aWZpY2F0ZShcclxuICAgICAgICBjb21tb25OYW1lLFxyXG4gICAgICAgIGFsdGVybmF0aXZlTmFtZXMsXHJcbiAgICAgICAgY2VydE9wdGlvbnNcclxuICAgICAgKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRlYnVnKFxyXG4gICAgICAgIGBDZXJ0aWZpY2F0ZSBmb3IgJHtjb21tb25OYW1lfSB3YXMgbm90IGNsb3NlIHRvIGV4cGlyaW5nIChvbiAke2V4cGlyZURhdGUudG9EYXRlU3RyaW5nKCl9KS5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoIW9wdGlvbnMuc2tpcEhvc3RzRmlsZSkge1xyXG4gICAgYXdhaXQgY3VycmVudFBsYXRmb3JtLmFkZERvbWFpblRvSG9zdEZpbGVJZk1pc3NpbmcoY29tbW9uTmFtZSk7XHJcbiAgfVxyXG5cclxuICBkZWJ1ZyhgUmV0dXJuaW5nIGRvbWFpbiBjZXJ0aWZpY2F0ZWApO1xyXG5cclxuICBjb25zdCByZXQgPSB7XHJcbiAgICBrZXk6IHJlYWRGaWxlKGRvbWFpbktleVBhdGgpLFxyXG4gICAgY2VydDogcmVhZEZpbGUoZG9tYWluQ2VydFBhdGgpXHJcbiAgfSBhcyBJUmV0dXJuRGF0YTxPPjtcclxuICBpZiAob3B0aW9ucy5nZXRDYUJ1ZmZlcikgKHJldCBhcyBDYUJ1ZmZlcikuY2EgPSByZWFkRmlsZShyb290Q0FDZXJ0UGF0aCk7XHJcbiAgaWYgKG9wdGlvbnMuZ2V0Q2FQYXRoKSAocmV0IGFzIENhUGF0aCkuY2FQYXRoID0gcm9vdENBQ2VydFBhdGg7XHJcblxyXG4gIHJldHVybiByZXQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayB3aGV0aGVyIGEgY2VydGlmaWNhdGUgd2l0aCBhIGdpdmVuIGNvbW1vbl9uYW1lIGhhcyBiZWVuIGluc3RhbGxlZFxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSBjb21tb25OYW1lIC0gY29tbW9uTmFtZSBvZiBjZXJ0aWZpY2F0ZSB3aG9zZSBleGlzdGVuY2UgaXMgYmVpbmcgY2hlY2tlZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGhhc0NlcnRpZmljYXRlRm9yKGNvbW1vbk5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gIHJldHVybiBleGlzdHMocGF0aEZvckRvbWFpbihjb21tb25OYW1lLCBgY2VydGlmaWNhdGUuY3J0YCkpO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IGEgbGlzdCBvZiBkb21haW5zIHRoYXQgY2VydGlmaWF0ZXMgaGF2ZSBiZWVuIGdlbmVyYXRlZCBmb3JcclxuICogQGFscGhhXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29uZmlndXJlZERvbWFpbnMoKTogc3RyaW5nW10ge1xyXG4gIHJldHVybiByZWFkZGlyKGRvbWFpbnNEaXIpO1xyXG59XHJcblxyXG4vKipcclxuICogUmVtb3ZlIGEgY2VydGlmaWNhdGVcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0gY29tbW9uTmFtZSAtIGNvbW1vbk5hbWUgb2YgY2VydCB0byByZW1vdmVcclxuICogQGRlcHJlY2F0ZWQgcGxlYXNlIHVzZSB7QGxpbmsgcmVtb3ZlQW5kUmV2b2tlRG9tYWluQ2VydCB8IHJlbW92ZUFuZFJldm9rZURvbWFpbkNlcnR9IHRvIGVuc3VyZSB0aGF0IHRoZSBPcGVuU1NMIGNlcnQgcmVtb3ZhbCBpcyBoYW5kbGVkIHByb3Blcmx5XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRG9tYWluKGNvbW1vbk5hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gIHJpbXJhZi5zeW5jKHBhdGhGb3JEb21haW4oY29tbW9uTmFtZSkpO1xyXG59XHJcblxyXG4vKipcclxuICogUmVtb3ZlIGEgY2VydGlmaWNhdGUgYW5kIHJldm9rZSBpdCBmcm9tIHRoZSBPcGVuU1NMIGNlcnQgZGF0YWJhc2VcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0gY29tbW9uTmFtZSAtIGNvbW1vbk5hbWUgb2YgY2VydCB0byByZW1vdmVcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZW1vdmVBbmRSZXZva2VEb21haW5DZXJ0KFxyXG4gIGNvbW1vbk5hbWU6IHN0cmluZ1xyXG4pOiBQcm9taXNlPHZvaWQ+IHtcclxuICBkZWJ1ZyhgcmVtb3ZpbmcgZG9tYWluIGNlcnRpZmljYXRlIGZvciAke2NvbW1vbk5hbWV9YCk7XHJcbiAgY29uc3QgY2VydEZvbGRlclBhdGggPSBwYXRoRm9yRG9tYWluKGNvbW1vbk5hbWUpO1xyXG4gIGNvbnN0IGRvbWFpbkNlcnRQYXRoID0gY2VydFBhdGhGb3JEb21haW4oY29tbW9uTmFtZSk7XHJcbiAgaWYgKGV4aXN0c1N5bmMoY2VydEZvbGRlclBhdGgpKSB7XHJcbiAgICBkZWJ1ZyhgY2VydCBmb3VuZCBvbiBkaXNrIGZvciAke2NvbW1vbk5hbWV9YCk7XHJcbiAgICAvLyByZXZva2UgdGhlIGNlcnRcclxuICAgIGRlYnVnKGByZXZva2luZyBjZXJ0ICR7Y29tbW9uTmFtZX1gKTtcclxuICAgIGF3YWl0IHJldm9rZURvbWFpbkNlcnRpZmljYXRlKGNvbW1vbk5hbWUpO1xyXG4gICAgLy8gZGVsZXRlIHRoZSBjZXJ0IGZpbGVcclxuICAgIGRlYnVnKFxyXG4gICAgICBgZGVsZXRpbmcgY2VydCBvbiBkaXNrIGZvciAke2NvbW1vbk5hbWV9IC0gJHtcclxuICAgICAgICBzdGF0U3luYyhkb21haW5DZXJ0UGF0aCkuc2l6ZVxyXG4gICAgICB9YFxyXG4gICAgKTtcclxuICAgIHJlbW92ZURvbWFpbihjb21tb25OYW1lKTtcclxuICAgIGRlYnVnKFxyXG4gICAgICBgZGVsZXRlZCBjZXJ0IG9uIGRpc2sgZm9yICR7Y29tbW9uTmFtZX0gLSAke2V4aXN0c1N5bmMoZG9tYWluQ2VydFBhdGgpfWBcclxuICAgICk7XHJcbiAgfSBlbHNlIGRlYnVnKGBjZXJ0IG5vdCBmb3VuZCBvbiBkaXNrICR7Y29tbW9uTmFtZX1gKTtcclxuICBkZWJ1ZyhgY29tcGxldGVkIHJlbW92aW5nIGRvbWFpbiBjZXJ0aWZpY2F0ZSBmb3IgJHtjb21tb25OYW1lfWApO1xyXG59XHJcbiJdfQ==